[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "yet another blog",
    "section": "",
    "text": "Lifetime annotations in Rust\n\n\n\n\n\n\n\nrust\n\n\n\n\n\n\n\n\n\n\n\nJun 19, 2023\n\n\n\n\n\n\n  \n\n\n\n\nHi\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nMar 1, 2023\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi, I’m Jon; I currently work in the Research Engineering group at The Alan Turing Institute. I did my PhD at Oxford in chemistry, specifically NMR spectroscopy: you might know me from some of the stuff that I’ve done there, such as the GENESIS website for NOAH supersequences.\nI’m not entirely sure why you, the reader, would be interested in what I have to write. I’m hardly an expert on anything (except, perhaps, my PhD area—but I’ve written enough about it), and there are many people whose opinions matter more. But, hey, why not, I guess.\nI’m not on social media much anymore, so there’s just a solitary link to my GitHub profile."
  },
  {
    "objectID": "posts/hello/index.html",
    "href": "posts/hello/index.html",
    "title": "Hi",
    "section": "",
    "text": "print(\"Hello, world.\")\n\n[1] \"Hello, world.\"\n\n\nKeeping a (technical) blog has been something I’ve thought of for quite a while. I’ve usually been held back by my uncertainty over why someone would ever want to read a technical blog by me: although I know plenty of things, I hardly have in-depth knowledge about anything, so I’ve always figured that there were people who were better at writing these things. There are already so many blogs out there, and I often feel that I don’t really want to add to the Huge Mess.\nBut I somehow managed to sign myself up at work to make blog posts, so now I’ve got to do something. Now, at work, I’m probably going to be writing about machine learning basics, and that’s hardly a topic lacking on the Internet. But—I suppose, the one thing I do know a fair bit about is chemistry, since that’s what I’ve spent 8 years of my life studying. I post a lot about chemistry elsewhere, and on several occasions (in real life) I’ve had people tell me that they found my writeups useful.\nSo, maybe I’ll intersperse my less-useful posts with some half-useful posts about chemistry…? And even if nobody reads it, this is probably useful for myself anyway!"
  },
  {
    "objectID": "posts/lifetimes/index.html",
    "href": "posts/lifetimes/index.html",
    "title": "Lifetime annotations in Rust",
    "section": "",
    "text": "Disclaimer: I don’t actually write Rust for anything, and the following is entirely based on my interpretation of one single paragraph in the Rust book, so I may be completely wrong."
  },
  {
    "objectID": "posts/lifetimes/index.html#introduction",
    "href": "posts/lifetimes/index.html#introduction",
    "title": "Lifetime annotations in Rust",
    "section": "Introduction",
    "text": "Introduction\nAt today’s Rust reading group we were discussing lifetimes. Most of the features covered in the Rust book until now (such as pattern matching, algebraic data types, traits, and generics) are directly analogous to concepts in Haskell, so I’ve been feeling reasonably comfortable. But lifetimes are something very alien to me.1\nIf you don’t think about it too hard, the standard example given in Section 10.3 of the Rust book seems almost self-evident. I added a few comments (in lines 10, 13, and 15), specifying the ‘true’ lifetimes of x, y, and result as 'p, and 'q, and 'r respectively, to make the following discussion clearer. (You can use the Rust playground to execute the code snippets.)\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main () {\n    // longer lifetime, let's call this 'p\n    let string1 = String::from(\"long string is long\");\n    {\n        // shorter lifetime, let's call this 'q\n        let string2 = String::from(\"xyz\");\n        // lifetime of the result, let's call this 'r\n        let result = longest(string1.as_str(), string2.as_str());\n        println!(\"The longest string is {}\", result);\n    };\n}\nUnfortunately, I found some aspects of the book a little bit confusing. For example, the caption of Listing 10-21 (where longest() is defined) says:\n\nThe longest function definition specifying that all the references in the signature must have the same lifetime 'a\n\nIt is not really obvious how this is true, because string1 and string2 certainly do not have the same lifetime.\nIn fact, if we think about lifetimes in the same way we do types, then it is not clear how the function can even be called with two arguments that do not have the same lifetime. For example, the following would obviously fail the function fst requires that x and y have the same type (which they do not):\nfn fst&lt;T&gt;(x: T, y: T) -&gt; T {\n    x\n}\n\nfn main() {\n    let x = 1;\n    let y = \"errrrr\";\n    let z = fst(x, y);\n}"
  },
  {
    "objectID": "posts/lifetimes/index.html#lifetime-semantics",
    "href": "posts/lifetimes/index.html#lifetime-semantics",
    "title": "Lifetime annotations in Rust",
    "section": "Lifetime semantics",
    "text": "Lifetime semantics\nThe resolution to this seeming contradiction is that the lifetime 'a passed in is not the lifetime of string1, nor is it the lifetime of string2. It is an entirely separate lifetime which the compiler determines, based on the lifetimes of the two arguments. This is expanded upon in later paragraphs, which in my opinion are the key to understanding all of this:\n\nRemember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. […] When we pass concrete references to longest, the concrete lifetime that is substituted for 'a is the part of the scope of x that overlaps with the scope of y. In other words, the generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y. Because we’ve annotated the returned reference with the same lifetime parameter 'a, the returned reference will also be valid for the length of the smaller of the lifetimes of x and y.\n\nSo, the compiler has to find a concrete value for 'a which is valid for both x and y—it must be a subset of both the true lifetimes 'p and 'q. If it is not possible to do this, then the compiler should complain.2 Of course, since the two true lifetimes overlap with each other, the compiler can choose 'a to be the smaller of the two, which happily satisfies the requirement above.\n\n\n\nResolving the lifetime parameters in longest, step 1.\n\n\nNotice that we haven’t considered the lifetime of the return value yet, 'r. This is because the return lifetime is not used to calculate what 'a should be. Instead, once the compiler has calculated 'a, it then assigns this lifetime to 'r. It must then check that the return value is not used outside of this lifetime.\n\n\n\nResolving the lifetime parameters in longest, step 2.\n\n\nI suppose, then, that for a function with annotated lifetimes, there are two ways in which the compiler may complain:\n\nThe compiler cannot find a lifetime 'a which satisfies all input variables. I have not yet been able to come up with an example of this. (Suggestions are welcome.)\nThe lifetime 'a is found, but the return value is used outside of this. An example of this is provided in Listing 10-23 of the Rust book:\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n}"
  },
  {
    "objectID": "posts/lifetimes/index.html#lifetime-bounds",
    "href": "posts/lifetimes/index.html#lifetime-bounds",
    "title": "Lifetime annotations in Rust",
    "section": "Lifetime bounds",
    "text": "Lifetime bounds\nWith this understanding of the basic example, we can now tackle a slightly more complicated one, which came up during the reading group. This one uses so-called ‘lifetime bounds’: the 'b: 'a syntax in the function signature stipulates that the lifetime 'b must be at least as long as the lifetime 'a.\nfn longest2&lt;'a, 'b: 'a&gt;(x: &'a str, y: &'b str) -&gt; &'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main () {\n    // longer lifetime, let's call this 'p\n    let string1 = String::from(\"long string is long\");\n    {\n        // shorter lifetime, let's call this 'q\n        let string2 = String::from(\"xyz\");\n        // lifetime of the result, let's call this 'r\n        let result = longest2(string1.as_str(), string2.as_str());\n        println!(\"The longest2 string is {}\", result);\n    };\n}\nSince the true lifetimes of the variables are such that'q &lt; 'p, it is not clear why the compiler should accept this. After all, the function signature seems to suggest that the second parameter must outlive the first.\nHowever, the entire point is that 'a and 'b are not the same as 'p and 'q; they are new lifetimes which are determined by the compiler. Going along the lines of the discussion above, the compiler must now find two lifetimes 'a and 'b which satisfy the following constraints:\n\n'a ≤ 'p (because of the first parameter)\n'b ≤ 'q (because of the second parameter)\n'b ≥ 'a (because of the lifetime bound)\n\nOne can see that if we instantiate both lifetimes 'a and 'b as being equal to 'q, then all three of these requirements are met.\n\n\n\nA happy resolution for the lifetime parameters in longest2."
  },
  {
    "objectID": "posts/lifetimes/index.html#is-longest2-more-restrictive",
    "href": "posts/lifetimes/index.html#is-longest2-more-restrictive",
    "title": "Lifetime annotations in Rust",
    "section": "Is longest2 more restrictive?",
    "text": "Is longest2 more restrictive?\nWith this knowledge, we might now consider whether there any possible cases in which using longest2 will raise a compiler error, while longest compiles just fine. (Or vice versa!)\nMy inclination is no: in other words, I think longest and longest2 are entirely equivalent. My proof is only halfway there, though.\n\nIf we can satisfy the function signature for longest, then we can satisfy that for longest2.\nIf we have a valid call to longest, that means that there exists some lifetime 'a which satisfies both 'a ≤ 'p and 'a ≤ 'q'.\nIf we then switch this call to one of longest2, we need to find a new lifetime 'b which obeys the three requirements above, namely: 'a ≤ 'p, 'b ≤ 'q, and 'b ≥ 'a. The first of these is already satisfied, and we can satisfy the other two by simply choosing 'b to be equal to 'a, making the call to longest2 also valid.\nIf we can satisfy the function signature for longest2, then we can satisfy that for longest.\nIf we have a valid call to longest2, then there exists two lifetimes 'a and 'b which satisfy 'a ≤ 'p, 'b ≤ 'q, and 'b ≥ 'a.\nThe requirements for longest are that we must find a lifetime 'c (different letter chosen to avoid clashes) for which 'c ≤ 'p and 'c ≤ 'q. If we just choose 'c to be equal to 'a, we are done.\n\nCollectively, this means that any combination of inputs that forms a valid call to longest will also form a valid call to longest2, and vice versa.\nThe catch is that there’s also a lifetime for the return value to consider. In theory, it could be possible that the values returned by longest and longest2 might have different lifetimes, and thus it would be possible to use a value obtained from longest in a location where using a value from longest2 would lead to an error (or vice versa).\nTo be clear, I don’t actually think this is the case. Intuitively, it seems to me that the return lifetime 'r should be resolved to the same value in both cases, namely the intersection of the true lifetimes 'p and 'q; but I haven’t actually proven this. One for another post, perhaps…"
  },
  {
    "objectID": "posts/lifetimes/index.html#footnotes",
    "href": "posts/lifetimes/index.html#footnotes",
    "title": "Lifetime annotations in Rust",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHaskell is garbage-collected.↩︎\nIn other words, this is an existential quantifier: the compiler must prove that there exists some lifetime 'a such that 'a ≤ 'p and 'a ≤ 'q.↩︎"
  }
]