[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi, I’m Jon; I currently work in the Research Engineering group at The Alan Turing Institute. I did my PhD at Oxford in chemistry, specifically NMR spectroscopy: you might know me from some of the stuff that I’ve done there, such as the GENESIS website for NOAH supersequences.\nI’m not entirely sure why you, the reader, would be interested in what I have to write. I’m hardly an expert on anything (except, perhaps, my PhD area—but I’ve written enough about it), and there are many people whose opinions matter more. But, hey, why not, I guess.\nI’m not on social media much anymore, so there’s just a solitary link to my GitHub profile."
  },
  {
    "objectID": "posts/pulprog/part2.html",
    "href": "posts/pulprog/part2.html",
    "title": "Pulse programming in TopSpin, part 2",
    "section": "",
    "text": "Here we’ll write our very first pulse programme from scratch, namely a pulse–acquire sequence.\n(This is part 2 of a series of posts on pulse programming in TopSpin. For the other parts, see the table of contents here.)"
  },
  {
    "objectID": "posts/pulprog/part2.html#the-header",
    "href": "posts/pulprog/part2.html#the-header",
    "title": "Pulse programming in TopSpin, part 2",
    "section": "The header",
    "text": "The header\nWe’ll start by adding some comments at the top of the file, to tell us what the pulse programme is about. Comments get used for lots of things, including instructions on how to run the pulse sequence, suggested parameter values, literature references, and so on.\nAnything after a semicolon indicates a comment, so the following lines are all comments. Start by adding a few lines of description, similar to these, at the very top of the pulse programme.\n; jy_pulacq\n; pulse-acquire sequence\n; Jonathan Yong, 4 July 2021\nNext, we need to include a definition file, which contains a series of instructions for the spectrometer.1\n#include &lt;Avance.incl&gt;\nIt’s quite unlikely that you’ll ever need to care about this, so it suffices to say that every pulse programme needs this, and that you should insert it. There are other definition files out there which “enhance” the pulse programming capabilities. We will deal with those when we need to.\nAt this point, it’s probably a good idea (although by no means mandatory) to add 1 or 2 blank lines before continuing."
  },
  {
    "objectID": "posts/pulprog/part2.html#the-recovery-delay",
    "href": "posts/pulprog/part2.html#the-recovery-delay",
    "title": "Pulse programming in TopSpin, part 2",
    "section": "The recovery delay",
    "text": "The recovery delay\nBefore we apply a pulse to a nucleus, we should ideally like the spin system to be at equilibrium. In order to do so, we need to start off the pulse sequence with a delay, which refers to a period in which nothing happens (no pulses are applied, etc.) The delay at the start of the pulse programme is typically called a recovery delay, or relaxation delay.\nDelays are specified using the syntax dX, where X is a number between 0 and 31. Traditionally, for the recovery delay, we use X=1; thus the recovery delay is usually denoted by d1. (In principle it can be any number, however.) Add this to the bottom of your pulse programme, which should now look something like:\n; jy_pulacq\n; pulse-acquire sequence\n; Jonathan Yong, 4 July 2021\n\n#include &lt;Avance.incl&gt;\n\nd1"
  },
  {
    "objectID": "posts/pulprog/part2.html#the-pulse",
    "href": "posts/pulprog/part2.html#the-pulse",
    "title": "Pulse programming in TopSpin, part 2",
    "section": "The pulse",
    "text": "The pulse\nPulses are specified using the syntax (pX phY):fZ, where:\n\nX is a number (between 0 and 31) which specifies the duration of the pulse (in µs), also called the pulse width.\nIf we have X=1, for example, then the pulse width will be given by the TopSpin parameter p1. We will see later that this can be specified in the acquisition parameter screen.\nY is a number (also between 0 and 31) which specifies the phase cycle to use for the pulse.\nUnlike the pulse width, the phase cycle must be written inside the pulse programme itself.\nZ is a number indicating the channel which the pulse is applied on. Pulses for different nuclei must be executed on different channels (because they have different resonance frequencies). For now this will always be 1, which generally corresponds to the 1H channel.\n\nFor now, we’ll keep it simple and use 1 throughout. So go ahead and add to your pulse programme:\n(p1 ph1):f1\nNote that this should be on a separate line from the previous step’s d1! This signifies to TopSpin that the pulse is to be executed after the recovery delay."
  },
  {
    "objectID": "posts/pulprog/part2.html#the-acquisition",
    "href": "posts/pulprog/part2.html#the-acquisition",
    "title": "Pulse programming in TopSpin, part 2",
    "section": "The acquisition",
    "text": "The acquisition\nFID acquisition is most simply specified using the go keyword. Specifically, the syntax is go=X phY, where :\n\nX is a label telling us where to restart the pulse programme from if we want to acquire more than one scan. Labels can technically be anything, but conventionally numbers seem to be used the most often.\nY is another number (between 0 and 31) indicating the receiver phase cycle.Usually big numbers are used, so let’s go with 31 for now.\n\nWe haven’t created any labels yet. Where should we make one? Well, between scans, we probably want to make sure that we go back and execute the recovery delay, d1, again. So the label can be attached to d1. In order to do so, modify the d1 line by adding 1 in front of it followed by a space.2 If you’ve been following closely, your pulse programme should now look like:\n; jy_pulacq\n; pulse-acquire sequence\n; Jonathan Yong, 4 July 2021\n\n#include &lt;Avance.incl&gt;\n\n1 d1\n(p1 ph1):f1\nWe’ve now created the label called 1, which gives us something to put in the X above. We also decided above that Y is 31. So, we can now add the acquisition line at the bottom, again on a new line of its own:\ngo=1 ph31\nAt this point, the pulse sequence is over: we need to add the exit keyword to tell TopSpin this. So do this on a new line, immediately after the go statement."
  },
  {
    "objectID": "posts/pulprog/part2.html#specifying-the-phase-cycles",
    "href": "posts/pulprog/part2.html#specifying-the-phase-cycles",
    "title": "Pulse programming in TopSpin, part 2",
    "section": "Specifying the phase cycles",
    "text": "Specifying the phase cycles\nSo far, we’ve said that our pulse will have the phase cycle ph1, and the receiver will have the phase cycle ph31. But we haven’t actually said what any of these are. Let’s say we want a two-step \\((x, -x)\\) phase cycle for the pulse. This can be specified using\nph1 = 0 2\nRecall that ph1 was the phase cycle that we chose for our pulse. The 0 and 2 correspond to the \\(x\\) and \\(-x\\) phases respectively (1 and 3 would correspond to \\(y\\) and \\(-y\\), which we aren’t using here).\nThe receiver phase needs to be ‘in sync’ with the pulse phase, in order to make sure that the signal from multiple scans adds up. So we can similarly write:\nph31 = 0 2\nPlace both of these lines at the bottom of your pulse programme. The whole thing should now look something like\n; jy_pulacq\n; pulse-acquire sequence\n; Jonathan Yong, 4 July 2021\n\n#include &lt;Avance.incl&gt;\n\n1 d1\n(p1 ph1):f1\ngo=1 ph31\nexit\n\nph1 = 0 2\nph31 = 0 2\nWe’re almost there! In fact, if you save your pulse programme now (via Ctrl-S or Cmd-S or plain old File &gt; Save), then click Graphical Edit, you should something similar to the following.\n\n\n\nTopSpin’s graphical edit view of our (incomplete) zg pulse programme."
  },
  {
    "objectID": "posts/pulprog/part2.html#where-does-the-data-go",
    "href": "posts/pulprog/part2.html#where-does-the-data-go",
    "title": "Pulse programming in TopSpin, part 2",
    "section": "Where does the data go?",
    "text": "Where does the data go?\nThere’s one more technical issue which we have to contend with before we can have a usable pulse programme, which is that the go acquisition keyword only records the data and stores it in a memory buffer.3 It doesn’t actually save our data to a file on the hard disk which we can read.4 This means we can’t actually access our data after the experiment ends, which (needless to say) is pretty bad!\nWe need one more command after go to tell the spectrometer to write the accumulated data to disk. This command is wr #0: the wr stands for ‘write’, and #0 is an internal symbol which tells TopSpin to save it to the current expno directory. (The expno is the number associated with each experiment; you can view this in TopSpin’s left sidebar.) Place this on a line of its own, after the go statement, but before the exit statement.\nAlso, it’s also a good idea to erase the memory buffer before starting the experiment, so that we start from scratch. This is done with the command zd. Place this before the 1 d1 line.\nAltogether, our pulse programme should look like this:\n; jy_pulacq\n; pulse-acquire sequence\n; Jonathan Yong, 4 July 2021\n\n#include &lt;Avance.incl&gt;\n\nzd\n1 d1\n(p1 ph1):f1\ngo=1 ph31\nwr #0\nexit\n\nph1 = 0 2\nph31 = 0 2\nThis is a fully functional pulse programme. If you made it all the way here, congratulations! In the next post, we’ll see how to run this experiment; we’ll also make some small but useful improvements to the pulse programme."
  },
  {
    "objectID": "posts/pulprog/part2.html#footnotes",
    "href": "posts/pulprog/part2.html#footnotes",
    "title": "Pulse programming in TopSpin, part 2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIf you want to see what’s inside this file, you can find it at .../lists/pp/Avance.incl. It’s mostly indecipherable. Don’t modify it!↩︎\nWith numbers it suffices to put the number and a space in front, but with other strings, you need to add a comma. For example, if you wanted the label recovery, then you would have to write recovery, d1.↩︎\nThe contents of this memory buffer can be viewed in the rightmost ‘Acqu’ tab in TopSpin.↩︎\nIf it’s not obvious what this means, think of it as opening a new file and typing a bunch of useful stuff in, but never actually saving it somewhere on the computer. Once you close the file, it’s gone forever.↩︎"
  },
  {
    "objectID": "posts/pulprog/part6.html",
    "href": "posts/pulprog/part6.html",
    "title": "Pulse programming in TopSpin, part 6",
    "section": "",
    "text": "Here, we’ll introduce pulsed field gradients, which are ways of temporarily creating a magnetic field with a fixed amount of inhomogeneity.\nThese are ubiquitous in modern NMR experiments, where their main purpose is to select specific types of desired magnetisation and to reject (dephase) all other magnetisation. We will see how this works using a simple spin echo experiment.\n(This is part 6 of a series of posts on pulse programming in TopSpin. For the other parts, see the table of contents here.)"
  },
  {
    "objectID": "posts/pulprog/part6.html#a-note-about-units",
    "href": "posts/pulprog/part6.html#a-note-about-units",
    "title": "Pulse programming in TopSpin, part 6",
    "section": "A note about units",
    "text": "A note about units\nDelays are specified in seconds, so if you want 10 ms, you need to enter 0.010, not 10. On the other hand, pulses are specified in microseconds, so if you want a 10 ms pulse you would need to enter 10000. Forgetting these units is an extremely common source of error!\nTo avoid this, in the ased screen and elsewhere in TopSpin, you can explicitly enter the units. When entering units, seconds are specified using s, milliseconds using m, and microseconds with u. Thus, instead of entering 0.010, you could also enter 10m. You should give this a try: notice how when you input 10m and press Enter, it automatically gets changed to 0.010.\nThis technique can be used for both delays and pulses. We haven’t yet come across any pulses that are longer than a few microseconds, but in the next post we will meet shaped pulses which are typically on the order of milliseconds."
  },
  {
    "objectID": "posts/pulprog/part6.html#running-the-experiment",
    "href": "posts/pulprog/part6.html#running-the-experiment",
    "title": "Pulse programming in TopSpin, part 6",
    "section": "Running the experiment",
    "text": "Running the experiment\nRun the experiment and process it. You should see some distorted multiplets like the following (if your sample doesn’t have any multiplets, you’d need to look for a more complicated sample).\n\n\n\nDistorted multiplets arising from the spin echo sequence.\n\n\n(If you are familiar with product operators, you should quickly convince yourself as to why these multiplets are distorted—or in other words, not purely in phase.)"
  },
  {
    "objectID": "posts/pulprog/part6.html#parameter-descriptions",
    "href": "posts/pulprog/part6.html#parameter-descriptions",
    "title": "Pulse programming in TopSpin, part 6",
    "section": "Parameter descriptions",
    "text": "Parameter descriptions\nAs before, we might want to include some extra comments at the bottom of the pulse programme which are displayed in the ased screen. Each gradient gpZ actually has four parts to it: the name of the gradient gpnamZ, the \\(x\\)-amplitude gpxZ, the \\(y\\)-amplitude gpyZ, and the \\(z\\)-amplitude gpzZ. The name gpnamZ refers to a file, which in turn specifies the shape of the gradient; so gpnamZ can indirectly be thought of as the shape of the gradient. The three different amplitude components refer to the axis along which the field inhomogeneity is applied (conventionally, \\(z\\) refers to the vertical axis in the laboratory frame). These are specified in terms of percentages of the maximum permissible field gradient: thus, you should never exceed 100%!2\nMany standard probes can only do \\(z\\)-gradients, which forces gpx and gpy to be both zero; thus, it is quite common to write comments for only the gpz and gpnam components.\nIn principle, you can put any text you like as the parameter description: after all, it’s just a comment. But practically speaking, there is a Python script bundled with TopSpin called gppp.py: this script reads the parameter descriptions from the pulse programme and sets the values of gpnam and gpz accordingly, which is quite convenient.3 In order for this script to work, you have to specify these in a particular format. The simplest possibility is to simply set the parameter description to the value that these parameters should take.\n;gpz1  : 10%\n;gpnam1: SMSQ10.100\nAlternatively, you can add some descriptive text behind the gpz values to tell the user what the role of the gradient is.\n;gpz1  : 10% (CTP gradient)\n;gpnam1: SMSQ10.100\nIn any case, you should add these to your pulse programme if you haven’t already. Then, go to the ased screen, and type gppp into the TopSpin command line. The chosen values for gpz1 and gpnam1 should be automatically populated.\nRun the spectrum; you should see that this is not very different from before. (In other words, the 180° pulse should have been pretty close to perfect.) However, with more complicated experiments, it is definitely possible to observe improvements in spectral quality.\nIf you want to see some immediate effect, then change one of the gp1’s in the pulse programme to gp1*-1 (either one; it doesn’t matter). That is, the line should read p16:gp1*-1. This multiplies the amplitude of the gradient by -1, i.e. causes the gradient pair to be opposing each other. Rerun the experiment, and you should find that all your signal is gone!\nThis is because of a mismatch between the CTP selection gradients and the actual pulse programme. A 180° pulse inverts the coherences, i.e. it generates a \\(+1 \\to -1\\) CTP; but having opposing gradients selects for a CTP where the coherence on both sides is the same, such as \\(+1 \\to +1\\). Of course, no detectable CTP can simultaneously obey both, so we end up detecting nothing at all."
  },
  {
    "objectID": "posts/pulprog/part6.html#footnotes",
    "href": "posts/pulprog/part6.html#footnotes",
    "title": "Pulse programming in TopSpin, part 6",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe shape basically specifies how fast the gradient is to be turned on and off. In practice we almost exclusively use smoothed gradients which “ramp up” at the beginning slowly from 0, and “ramp down” at the end.↩︎\nWhat is the maximum permissible field gradient? You can type the edprobe command in TopSpin to find out. From the resulting box, select the probe you are currently using (consult someone if you’re not sure what you’re doing). Double-click on it: if it asks you for an admistration password, click Cancel. In the resulting list of parameters, you should notice the “maximum gradient strength in Z direction” in units of G/(cm A), and the “maximum permissible current in Z direction” in units of A. The maximum gradient strength in G/cm is then the product of these two quantities.↩︎\nTo see what’s in this Python script, you can type edpy gppp in the TopSpin command line.↩︎"
  },
  {
    "objectID": "posts/pulprog/part4.html",
    "href": "posts/pulprog/part4.html",
    "title": "Pulse programming in TopSpin, part 4",
    "section": "",
    "text": "Here, we’re going to make some small but useful improvements to our first pulse programme: namely the inclusion of dummy scans, and some “special” comments for parameter descriptions.\n(This is part 4 of a series of posts on pulse programming in TopSpin. For the other parts, see the table of contents here.)\n\nMaking a new version\nBefore going on, let’s create a new version of your pulse programme. Open up the current pulse programme: you can either do this via the edpul interface, or you can use the eda command and click the three dots next to the pulse programme name. Then click File &gt; Save as…. Choose the same directory as the one you were previously in, and for the filename, append .1 to your old filename:\n\n\n\nCreating a new pulse programme.\n\n\nIn my case, this means my new filename is jy_pulacq.1, as in the screenshot above. It’s generally a good idea to create a new pulse programme whenever you’re trying to iteratively improve an existing pulse programme. A common way to indicate this in filenames is the .&lt;N&gt; suffix, where N is some kind of “version number”. You can see this strategy used in some of the Bruker standard pulse sequences.\nOnce you hit OK, a window to edit the new pulse programme will appear. The key indicator is that the filename at the top bar will have changed. You should now modify the comment in the very first line to reflect this. Finally, press the Set PULPROG button to make this pulse programme the active one, so that the next time you run zg this pulse programme will be used.\n\n\n\nSuccessfully creating a new pulse programme.\n\n\n\n\nDummy scans\nIn the previous post, we said that dummy scans were used to set the system to a steady state before running the experiment. For a simple 1D experiment like this one, it doesn’t really matter too much; but for other experiments you can actually get different results depending on how many dummy scans you use.\nLet’s set the DS parameter to 2, i.e. enable 2 dummy scans. Since NS is 2, when we set DS to 2, this should double the experiment duration. Our previous experiment took 8 seconds, so this should take 16 seconds. Check this with expt:\n\n\n\nAn experiment with an incorrect duration.\n\n\nWhoops! What went wrong?\nIt turns out that the command zd which we previously used doesn’t “enable” the collection of dummy scans. In order to “turn this feature on”, we need to use the ze command instead.\nChange zd to ze, and near the top of your pulse programme, add a short comment to describe what changes you made in this version. If you haven’t done so already, click the Set PULPROG button. Re-run expt and make sure the duration has doubled. Then re-run the experiment with zg.\nIn a 1D experiment, you probably almost always want to use ze. On the other hand, zd is quite useful in 2D spectra: we basically only want to run dummy scans at the very start of the experiment, instead of at the beginning of every \\(t_1\\) increment. We’ll see why zd might be useful when we get to 2D spectra.\n\n\nParameter descriptions\nType ased again to get to the pulse sequence parameter screen. You might have previously noticed that to the right of each parameter, there are some descriptions for them. But for d1 and p1, the default descriptions are not very helpful:\n\n\n\nUnhelpful parameter descriptions in the ased screen.\n\n\nWhen setting up a new experiment, it’s often useful to have some kind of hint as to what the pulses and delays mean. The good news is that by adding some “special” comments in the the pulse programme, we can specify a one-line description which will be displayed to users in the ased screen. These comments must go below the actual pulse sequence (i.e. after the exit command), and must be in the following form:\n;name : description\nNote that there can’t be any spaces between the first semicolon and the parameter name, or else it won’t be parsed correctly. (Spaces elsewhere are optional.) Let’s go ahead and add a few descriptions at the bottom of our pulse programme:\n;p1 : 90 degree pulse width (from getprosol)\n;pl1 : hard pulse power (from getprosol)\n;d1 : recovery delay (ca. 1 s)\nSave the pulse programme and type ased again to refresh the screen. You should now see the new descriptions:\n\n\n\nMore helpful parameter descriptions.\n\n\nIncidentally, not all of the parameters can be specified in this way. Try it with NS, for example. You’ll find that you can’t override TopSpin’s default description for that.\n\n\nThe current pulse programme\nAt this point, your pulse programme should look something like the following, perhaps with a few extra comments\n; jy_pulacq.1\n; pulse-acquire sequence\n; Jonathan Yong, 5 July 2021\n\n; .1 - enabled dummy scans by changing zd to ze\n\n#include &lt;Avance.incl&gt;\n \nze\n1 d1\n(p1 ph1):f1\ngo=1 ph31 \nwr #0\nexit\n\nph1 = 0 2\nph31 = 0 2\n\n;p1 : 90 degree pulse width (from getprosol)\n;pl1 : hard pulse power (from getprosol)\n;d1 : recovery delay (ca. 1 s)\nWhen you’re ready, move on to the next post."
  },
  {
    "objectID": "posts/pulprog/part3.html",
    "href": "posts/pulprog/part3.html",
    "title": "Pulse programming in TopSpin, part 3",
    "section": "",
    "text": "Having written our first pulse programme, we’ll run it on the spectrometer! We’re going to assume that you already have a sample in the spectrometer prior to running any of these commands.\nObviously, this section can only really be done on a spectrometer terminal; you can’t run an experiment with the ‘processing-only’ version of TopSpin on your laptop.\n(This is part 3 of a series of posts on pulse programming in TopSpin. For the other parts, see the table of contents here.)"
  },
  {
    "objectID": "posts/pulprog/part3.html#the-parameters-of-interest",
    "href": "posts/pulprog/part3.html#the-parameters-of-interest",
    "title": "Pulse programming in TopSpin, part 3",
    "section": "The parameters of interest",
    "text": "The parameters of interest\n{% include note.html content=” Before proceeding, take a close look at the units for the different parameters in the ased screen. Delays are specified in seconds, whereas pulses are in microseconds. Mixing these up is a common source of errors! “%}\nOut of all these parameters, the only two that we actually specified in our pulse programme were D1 and P1.2\nFor D1, anything on the order of 1 second will work fine for a standard proton experiment, but you can really set this to be anything you like (for this experiment, at least).\nFor P1, we aren’t actually interested in a specific duration. What we should really aim for is a 90° flip angle, so that we tip the magnetisation from \\(+z\\) to \\(-y\\) or \\(+y\\) (since our pulse is applied either along \\(+x\\) or \\(-x\\).) You might recall from your general NMR reading that the flip angle \\(\\beta\\) is given by\n\\[\\beta = \\omega_1 t_\\mathrm{p}\\]\nwhere \\(\\omega_1\\) is the radiofrequency (RF) amplitude of the pulse (in Hz), and \\(t_\\mathrm{p}\\) is the pulse width (in units of time). This equation means that there are actually many different combinations of \\(\\omega_1\\) and \\(t_\\mathrm{p}\\) which yield a 90° flip angle: if \\(\\omega_1\\) is a bit larger, than \\(t_\\mathrm{p}\\) just needs to be a bit smaller.\nWe can set the pulse width \\(t_\\mathrm{p}\\) using the P1 parameter, but what about \\(\\omega_1\\)? It turns out that you can’t input \\(\\omega_1\\) directly in Hz, but you can do it indirectly via the PLW1 parameter, which is given in the mysterious units of W or dB. However, we are spared from actually having to figure out what this means, because whenever you run getprosol (or select it from the new dialog box), both of these values P1 and PLW1 will be set for you such that P1 roughly corresponds to a 90° pulse.3 These values are spectrometer-dependent, so do not copy the values in the screenshot above!\nFinally, to make our experiment go a bit quicker, let’s set DS=0 and NS=2. NS just refers to the number of scans. DS refers to dummy scans, which are scans that are executed before the experiment starts but without saving any data. We’ll have more to say about dummy scans later."
  },
  {
    "objectID": "posts/pulprog/part3.html#footnotes",
    "href": "posts/pulprog/part3.html#footnotes",
    "title": "Pulse programming in TopSpin, part 3",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNotice that there is a dropdown box at the top-right, which should contain paths like .../par/user and .../par. These have the same meaning to the pp directories which we’ve been using: the par/user directory is meant for user-defined parameter sets, whereas the par directory is meant for pre-installed parameter sets. If you cannot find anything sensible at all in the par/user directory (highly unlikely!), then you should be able to use the PROTON parameter set in the par directory.↩︎\nFor all of these parameters, you can find more detailed explanation in the TopSpin documentation: type docs in the command-line and select Acquisition Commands and Parameters.↩︎\nOf course, these values aren’t magically conjured from nothing. When the spectrometer was installed, somebody will have performed a careful pulse calibration to figure out a pair of appropriate values, so that you didn’t have to do it yourself. They would then have saved it, so that you could access it via getprosol.↩︎"
  },
  {
    "objectID": "posts/pulprog/index.html",
    "href": "posts/pulprog/index.html",
    "title": "Pulse programming in TopSpin",
    "section": "",
    "text": "You’re starting a PhD or undergrad project on NMR spectroscopy, and you’re going to be writing your own pulse sequences… which is great! This series of posts aims to be a gentle introduction to constructing and running pulse programmes, which is complementary to TopSpin’s reference manual.\n\nTable of contents\n\nPart 0: Prerequisites\nPart 1: Getting started with TopSpin\nPart 2: A basic pulse–acquire sequence\nPart 3: Running the experiment\nPart 4: Dummy scans and parameter descriptions\nPart 5: Using mathematical expressions\nPart 6: Gradients\nPart 7: A consolidation exercise\n\n\n\nA little bit of history\nThese posts were in fact written in 2021, when I was doing my PhD at Oxford. I have, however, set the post date to 2023 so that it doesn’t appear at the bottom of my blog. These used to be hosted on the Foroozandeh group blog, but I’ve since migrated them over to my own blog.\nThey are not complete in any way! When I wrote these, I had really intended to cover quite a lot of material, especially 2D NMR, which was a huge part of my PhD work. However, time got in the way, and I now no longer have access to NMR spectrometers since I’ve graduated."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "yet another blog",
    "section": "",
    "text": "Pulse programming in TopSpin\n\n\n\n\n\n\n\nnmr\n\n\npulse programming\n\n\n\n\n\n\n\n\n\n\n\nJul 23, 2023\n\n\n\n\n\n\n  \n\n\n\n\nLifetime annotations in Rust\n\n\n\n\n\n\n\nrust\n\n\n\n\n\n\n\n\n\n\n\nJun 19, 2023\n\n\n\n\n\n\n  \n\n\n\n\nHi\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nMar 1, 2023\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/lifetimes/index.html",
    "href": "posts/lifetimes/index.html",
    "title": "Lifetime annotations in Rust",
    "section": "",
    "text": "Disclaimer: I don’t actually write Rust for anything, and the following is entirely based on my interpretation of one single paragraph in the Rust book, so I may be completely wrong.\n(Edited after some discussion at work. Thanks to everyone who chimed in and helped me to understand this better!)"
  },
  {
    "objectID": "posts/lifetimes/index.html#introduction",
    "href": "posts/lifetimes/index.html#introduction",
    "title": "Lifetime annotations in Rust",
    "section": "Introduction",
    "text": "Introduction\nAt today’s Rust reading group we were discussing lifetimes. Most of the features covered in the Rust book until now (such as pattern matching, algebraic data types, traits, and generics) are directly analogous to concepts in Haskell, so I’ve been feeling reasonably comfortable. But lifetimes are something very alien to me.1\nIf you don’t think about it too hard, the standard example given in Section 10.3 of the Rust book seems almost self-evident. I added a few comments (in lines 10, 13, and 15), specifying the ‘true’ lifetimes of x, y, and result as 'p, and 'q, and 'r respectively, to make the following discussion clearer. (You can use the Rust playground to execute the code snippets.)\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main () {\n    // longer lifetime, let's call this 'p\n    let string1 = String::from(\"long string is long\");\n    {\n        // shorter lifetime, let's call this 'q\n        let string2 = String::from(\"xyz\");\n        // lifetime of the result, let's call this 'r\n        let result = longest(string1.as_str(), string2.as_str());\n        println!(\"The longest string is {}\", result);\n    };\n}\nUnfortunately, I found some aspects of the book a little bit confusing. For example, the caption of Listing 10-21 (where longest() is defined) says:\n\nThe longest function definition specifying that all the references in the signature must have the same lifetime 'a\n\nIt is not really obvious how this is true, because string1 and string2 certainly do not have the same lifetime.\nIn fact, if we think about lifetimes in the same way we do types, then it is not clear how the function can even be called with two arguments that do not have the same lifetime. For example, the following would obviously fail the function fst requires that x and y have the same type (which they do not):\nfn fst&lt;T&gt;(x: T, y: T) -&gt; T {\n    x\n}\n\nfn main() {\n    let x = 1;\n    let y = \"errrrr\";\n    let z = fst(x, y);\n}"
  },
  {
    "objectID": "posts/lifetimes/index.html#lifetime-semantics",
    "href": "posts/lifetimes/index.html#lifetime-semantics",
    "title": "Lifetime annotations in Rust",
    "section": "Lifetime semantics",
    "text": "Lifetime semantics\nThe resolution to this seeming contradiction is that the lifetime 'a passed in is not the lifetime of string1, nor is it the lifetime of string2. It is an entirely separate lifetime which the compiler determines, based on the lifetimes of the two arguments. This is expanded upon in later paragraphs, which in my opinion are the key to understanding all of this:\n\nRemember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. […] When we pass concrete references to longest, the concrete lifetime that is substituted for 'a is the part of the scope of x that overlaps with the scope of y. In other words, the generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y. Because we’ve annotated the returned reference with the same lifetime parameter 'a, the returned reference will also be valid for the length of the smaller of the lifetimes of x and y.\n\nSo, the compiler has to find a concrete value for 'a which is valid for both x and y—it must be a subset of both the true lifetimes 'p and 'q.\nOn top of that, the compiler must also ensure that this lifetime 'a is valid wherever the return value is being used. In other words, we must have 'a ≥ 'r.\nIf it is not possible to satisfy all of these conditions, then the compiler should complain.2 Of course, it is not very hard to find a suitable value for 'a in this particular case:\n\n\n\nResolving the lifetime parameters in longest.\n\n\nIn this very simple case, the constraints above essentially reduce to min('p', 'q') ≥ 'r'.3 This is what the book means when it says:\n\nIn practice, it means that the lifetime of the reference returned by the longest function is the same as the smaller of the lifetimes of the values referred to by the function arguments.\n\nThis also explains why the following snippet (Listing 10-23 in the book) fails to compile. At a high level, we can understand this as the return value result being used outside of the scope of string2.\nHowever, it would be more precise to say that this is because the compiler cannot find a concrete lifetime 'a which simultaneously satisfies all three constraints 'a ≤ 'p, 'a ≤ 'q, and 'a ≥ 'r.\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n}\n\n\n\nAn occasion where the lifetime parameters cannot be resolved."
  },
  {
    "objectID": "posts/lifetimes/index.html#lifetime-bounds",
    "href": "posts/lifetimes/index.html#lifetime-bounds",
    "title": "Lifetime annotations in Rust",
    "section": "Lifetime bounds",
    "text": "Lifetime bounds\nWith this understanding of the basic example, we can now tackle a slightly more complicated one, which came up during the reading group. This one uses so-called ‘lifetime bounds’: the 'b: 'a syntax in the function signature stipulates that the lifetime 'b must be at least as long as the lifetime 'a.\nfn longest2&lt;'a, 'b: 'a&gt;(x: &'a str, y: &'b str) -&gt; &'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main () {\n    // longer lifetime, let's call this 'p\n    let string1 = String::from(\"long string is long\");\n    {\n        // shorter lifetime, let's call this 'q\n        let string2 = String::from(\"xyz\");\n        // lifetime of the result, let's call this 'r\n        let result = longest2(string1.as_str(), string2.as_str());\n        println!(\"The longest2 string is {}\", result);\n    };\n}\nSince the true lifetimes of the variables are such that'q &lt; 'p, it is not clear why the compiler should accept this. After all, the function signature seems to suggest that the second parameter must outlive the first.\nHowever, the entire point is that 'a and 'b are not the same as 'p and 'q; they are new lifetimes which are determined by the compiler. Going along the lines of the discussion above, the compiler must now find two lifetimes 'a and 'b which together satisfy the following constraints:\n\n'a ≤ 'p (because of the first parameter)\n'b ≤ 'q (because of the second parameter)\n'b ≥ 'a (because of the lifetime bound)\n'a ≥ 'r (because of the return value)\n\nOne can see that if we instantiate both lifetimes 'a and 'b as being equal to 'q, then all three of these requirements are met.\n\n\n\nA happy resolution for the lifetime parameters in longest2."
  },
  {
    "objectID": "posts/lifetimes/index.html#is-longest2-more-restrictive",
    "href": "posts/lifetimes/index.html#is-longest2-more-restrictive",
    "title": "Lifetime annotations in Rust",
    "section": "Is longest2 more restrictive?",
    "text": "Is longest2 more restrictive?\nWith this knowledge, we might now consider whether there any possible cases in which using longest2 will raise a compiler error, while longest compiles just fine. (Or vice versa!)\nI think not, because:\n\nIf we can satisfy the function signature for longest, then we can satisfy that for longest2.\nIf we have a valid call to longest, that means that there already exists some lifetime 'a which satisfies 'a ≤ 'p, 'a ≤ 'q', and 'a ≥ 'r.\nIf we then switch this call to one of longest2, we need to find a new lifetime 'b which obeys the four requirements above, namely: 'a ≤ 'p, 'b ≤ 'q, 'b ≥ 'a, and 'a ≥ 'r.\nThe first and last of these are already satisfied, and we can satisfy the other two by simply choosing 'b to be equal to 'a, making the call to longest2 also valid.\nIf we can satisfy the function signature for longest2, then we can satisfy that for longest.\nIf we have a valid call to longest2, then there exist two lifetimes 'a and 'b which satisfy 'a ≤ 'p, 'b ≤ 'q, 'b ≥ 'a, and 'a ≥ 'r.\nThe requirements for longest are that we must find a lifetime 'c (different letter chosen to avoid clashes) for which 'c ≤ 'p, 'c ≤ 'q, and 'c ≥ 'r. If we just choose 'c to be equal to 'a, we are done.\n\nCollectively, this means that any valid call to longest can be replaced with a valid call to longest2 (and vice versa)."
  },
  {
    "objectID": "posts/lifetimes/index.html#footnotes",
    "href": "posts/lifetimes/index.html#footnotes",
    "title": "Lifetime annotations in Rust",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHaskell is garbage-collected.↩︎\nIn other words, this is an existential quantifier: the compiler must prove that there exists some lifetime 'a such that 'a ≤ 'p and 'a ≤ 'q.↩︎\nPerhaps we should talk about the intersection of 'p and 'q, rather than the minimum. But in this case, they are the same thing.↩︎"
  },
  {
    "objectID": "posts/pulprog/part5.html",
    "href": "posts/pulprog/part5.html",
    "title": "Pulse programming in TopSpin, part 5",
    "section": "",
    "text": "In this post, we’ll take a look at how we can modify and define parameters (such as pulse lengths) using mathematical expressions.\n(This is part 5 of a series of posts on pulse programming in TopSpin. For the other parts, see the table of contents here.)\n\nA new version…\nBefore going on, use the iexpno command in TopSpin to create a new experiment with the next expno. All experimental parameters will be carried over from the previous experiment.\nThen, create a new version of your pulse programme with the suffix .2. The steps to do this are described in the previous post. Save the pulse programme, and make sure to hit Set PULPROG.\n\n\nChanging the flip angle\nWe previously mentioned that the flip angle \\(\\beta\\) is given by\n\\[\\beta = \\omega_1 t_\\mathrm{p}.\\]\nAs long as we keep \\(\\omega_1\\) (which is indirectly specified by PLW1) constant, then we can control the flip angle by changing \\(t_\\mathrm{p}\\), which is P1.\nLet’s now change our pulse programme to use a 45° pulse instead of a 90° pulse. One way to do that would be to go into the ased screen and change P1 to half of its original value. However, that would mean that when setting up the experiment, we can’t use getprosol (or we would have to divide it by 2 every time)!\nIf we always want the flip angle to be 45°, then what we should do is to change the pulse programme. To be specific, we can change p1 to p1*0.5, so that the line with the pulse now becomes\n(p1*0.5 ph1):f1\nRun the experiment. You should find that the spectrum is qualitatively very similar: not much has changed. But quantitatively, we expect that the 45° degree pulse will have created less transverse magnetisation than the 90° pulse (by a factor of \\(\\cos(45^\\circ) \\approx 0.71\\)).\nIt’s hard to judge this by eye, but we can ascertain this by using TopSpin’s multiple display mode to superimpose two spectra. In the TopSpin command line, type .md, or click the appropriate button in the top panel (left is TopSpin 3, right TopSpin 4):\n\n\n\nFinding multiple-display mode in TopSpin 3 (left) and 4 (right).\n\n\nThen, drag the original, first dataset from the left-hand sidebar into the main part of TopSpin:\n\n\n\nAdding a new dataset to multiple display mode.\n\n\nTopSpin will now show you both datasets together, superimposed. Verify that the second dataset (with the 45° pulse) has a lower intensity than the first. (If you’re not familiar with this mode, it’s a good idea to also have a play around with the row of buttons at the top to see what you can do with them.) When you’re done, type .ret into the TopSpin command line, or click the right-most “return” button which looks like an arrow (boxed above).\n\n\nA user-defined flip angle\nNow, we have hardcoded a flip angle inside our pulse programme: anybody who uses this will end up with a 45° pulse (as long as their p1 corresponds to a 90° pulse, which it almost certainly will). But perhaps we should like to let the user choose their own flip angle. Parameters like these, which are neither pulses (the P family) nor delays (the D family), can be specified as constants (CNST). TopSpin allows you to specify constants ranging from CNST0 to CNST63.\nFirst, let’s change the hardcoded p1*0.5 to just p0, where p0 is going to be the pulse width that we end up with. (Recall that p1 is always the 90° pulse, which is why we’re using a different number here.) Suppose our flip angle is specified as CNST1 in degrees. Then, the following relationship must hold: p0 = p1 * cnst1 / 90.\nIn order to enforce this relationship, we can add it as a line before the pulse programme begins (i.e. before ze). Definitions such as these must be enclosed in double quotes. So, add the following line before the ze line:\n\"p0 = p1 * cnst1 / 90\"\n(Perhaps now is a good time to add some comments at the bottom of the file to explain what p0 and cnst1 are, so that the user can see it in the ased file!)\nOur pulse programme should now look something like the following:\n; jy_pulacq.2\n; pulse-acquire sequence\n; Jonathan Yong, 5 July 2021\n\n; .1 - enabled dummy scans by changing zd to ze\n; .2 - enable variable flip angle through cnst1\n\n#include &lt;Avance.incl&gt;\n\n\"p0 = p1 * cnst1 / 90\"\n\nze\n1 d1\n(p0 ph1):f1\ngo=1 ph31\nwr #0\nexit\n\nph1 = 0 2\nph31 = 0 2\n\n;p1    : 90 degree pulse width (from getprosol)\n;pl1   : hard pulse power (from getprosol)\n;p0    : X degree pulse width\n;cnst1 : flip angle in degrees\n;d1    : recovery delay (ca. 1 s)\nand the ased screen should be similar to this:\n\n\n\nNew ased screen with a variable flip angle.\n\n\nWhile in this screen, you should set cnst1 to several different values. Notice how every time you change cnst1, the value of p0 is automatically updated: this is a result of the relationship that we specified. The result of our work is that:\n\nThe user can always get p1 and pl1 using getprosol, and need not adjust it manually themselves.\nThe flip angle can be chosen at will by setting cnst1.\nThe pulse programme automatically calculates the correct pulse width corresponding to the user’s chosen flip angle.\n\nActually, if you just want to see or modify the value of one parameter, you don’t have to go to the ased screen and wade through the entire list. You can directly type cnst1 into the TopSpin command line, and TopSpin will show you a dialog box containing the current value of cnst1. If you want to change it, you can then enter a new value there.\n\n\n\nDirectly modifying cnst1 from the TopSpin command line.\n\n\nPlay around with this a bit: create a few different experiments with the iexpno command, and run each with different flip angles between (say) 0° and 360°. Then use multiple-display mode (.md) to compare the resulting spectra. You can even integrate the spectrum and plot the intensity as a function of the flip angle (it should have a sine profile).\nWhen you’re ready, move on to the next post, where we’ll introduce a more advanced topic: pulsed field gradients."
  },
  {
    "objectID": "posts/pulprog/part7.html",
    "href": "posts/pulprog/part7.html",
    "title": "Pulse programming in TopSpin, part 7",
    "section": "",
    "text": "This is a short post, featuring a small exercise designed to consolidate everything we’ve learnt so far.\n(This is part 7 of a series of posts on pulse programming in TopSpin. For the other parts, see the table of contents here.)"
  },
  {
    "objectID": "posts/pulprog/part7.html#footnotes",
    "href": "posts/pulprog/part7.html#footnotes",
    "title": "Pulse programming in TopSpin, part 7",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n(More advanced topics.) This idea of refocusing J-coupling seems to suggest that the perfect echo can be used as an element for pure shift NMR. However, this is not actually possible. The reason is because the perfect echo doesn’t just refocus J-couplings; it also causes coherence transfer between both spins. That is to say, any magnetisation that was on spin \\(I\\) in the first half of the perfect echo ends up on spin \\(S\\) in the second half, and vice versa. In contrast, pure shift elements like the PSYCHE double chirp refocus J-couplings without causing coherence transfer. (The fact that the perfect echo causes coherence transfers is not necessarily a bad thing: it has been used to great effect in the CLIP-COSY and other related sequences.)↩︎"
  },
  {
    "objectID": "posts/pulprog/part0.html",
    "href": "posts/pulprog/part0.html",
    "title": "Pulse programming in TopSpin, part 0",
    "section": "",
    "text": "In this introductory post, we’ll talk about some of the concepts you might want to look at prior to making new experiments on a spectrometer.\n(This is part 0 of a series of posts on pulse programming in TopSpin. For the other parts, see the table of contents here.)\n\nPrerequisites\nBefore launching into how to construct a pulse programme, you should know what a pulse sequence is. I don’t intend to teach basic principles of NMR here, as that job is better done by a textbook: this series of posts only addresses the implementation of the pulse sequences on an actual spectrometer.\nYou don’t need to be able to explain exactly what the pulse sequence accomplishes, or to identify this sequence right away. However, you should be able to understand what some of these symbols mean:\n\n\n\nA standard HSQC sequence.\n\n\nSo, (ideally) you should know some of the following:\n\nFilled bars indicate 90° pulses, and empty bars indicate 180° pulses. (This isn’t a universal convention, but we will use it here.)\nPulses can be applied on different nuclei, which the left-hand side labels (e.g. \\(\\ce{^1H}\\)) indicate.\nEmpty spaces between pulses represent delays where nothing is done. The duration of each delay is indicated as some symbol.\nThe \\(G_z\\) row contains pulsed field gradients.\nThe squiggly bit at the end indicates acquisition of an FID.\nDecoupling is applied during the FID.\n\nIf you have seen all of these, that’s perfect!\nIf you have at least seen some of these, chances are you can read on, as we will briefly introduce each component as we go along.\nIf you have never seen this kind of diagram before, then I suggest reading an introductory NMR book. I personally recommend James Keeler’s Understanding NMR Spectroscopy, 2nd ed. If you can’t find this at a library, there are PDFs of an older version which can be downloaded from here.\nFor the entire series of posts, you will likely need to read up to the chapter on pulsed field gradients, although the chapter on relaxation can be skipped. It may seem like a lot, but my opinion is that at some point in time you will probably need to read it anyway, so you may as well start off with some good foundations.\nFor a very brief overview, or a refresher, the first chapter of Tim Claridge’s High-Resolution NMR Techniques in Organic Chemistry, 3rd ed., or the last chapter of Peter Hore’s Nuclear Magnetic Resonance, 2nd ed. will suffice."
  },
  {
    "objectID": "posts/pulprog/part1.html",
    "href": "posts/pulprog/part1.html",
    "title": "Pulse programming in TopSpin, part 1",
    "section": "",
    "text": "Before diving into the syntax of a pulse programme, we’ll first take a quick look at where pulse programmes are stored in TopSpin, and how you can inspect and edit them.\n(This is part 1 of a series of posts on pulse programming in TopSpin. For the other parts, see the table of contents here.)"
  },
  {
    "objectID": "posts/pulprog/part1.html#adding-your-own-directory-optional",
    "href": "posts/pulprog/part1.html#adding-your-own-directory-optional",
    "title": "Pulse programming in TopSpin, part 1",
    "section": "Adding your own directory (optional)",
    "text": "Adding your own directory (optional)\nIf you plan to do a lot of pulse programming, you may eventually want to create your own personal directory in order to avoid cluttering .../lists/pp/user. This directory can be created can be anywhere on the computer, but you have to instruct TopSpin to add the directory to the search path.\nTo do this, open TopSpin preferences (in TopSpin 3 this is under the Manage tab; in TopSpin 4 this is the gear icon in the top-right). Click on the Directories section, and click on Manage source directories for edpul, edau, etc.. Then add your own folder to the first box labelled Pulse programs.\nIn the following screenshot, I’ve added the directory /Users/yongrenjie/Desktop/pp at the very top; this means that TopSpin will search inside this first, before it looks inside the default directories.\n\n\n\nAdding a new source directory for pulse programmes."
  },
  {
    "objectID": "posts/hello/index.html",
    "href": "posts/hello/index.html",
    "title": "Hi",
    "section": "",
    "text": "print(\"Hello, world.\")\n\n[1] \"Hello, world.\"\n\n\nKeeping a (technical) blog has been something I’ve thought of for quite a while. I’ve usually been held back by my uncertainty over why someone would ever want to read a technical blog by me: although I know plenty of things, I hardly have in-depth knowledge about anything, so I’ve always figured that there were people who were better at writing these things. There are already so many blogs out there, and I often feel that I don’t really want to add to the Huge Mess.\nBut I somehow managed to sign myself up at work to make blog posts, so now I’ve got to do something. Now, at work, I’m probably going to be writing about machine learning basics, and that’s hardly a topic lacking on the Internet. But—I suppose, the one thing I do know a fair bit about is chemistry, since that’s what I’ve spent 8 years of my life studying. I post a lot about chemistry elsewhere, and on several occasions (in real life) I’ve had people tell me that they found my writeups useful.\nSo, maybe I’ll intersperse my less-useful posts with some half-useful posts about chemistry…? And even if nobody reads it, this is probably useful for myself anyway!"
  }
]